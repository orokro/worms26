const fs = require('fs');
const path = require('path');

// Configuration
const INPUT_DIR = 'SpriteBitmaps';
const WORMS_DIR = path.join(INPUT_DIR, 'Worms');
const OUTPUT_DIR_C = 'c';
const OUTPUT_DIR_H = 'h';
const OUTPUT_FILE_C = path.join(OUTPUT_DIR_C, 'SpriteData.c');
const OUTPUT_FILE_H = path.join(OUTPUT_DIR_H, 'SpriteData.h');

// File Header Boilerplate
const HEADER_COMMENT_C = `/*
	SpriteData.c
	------------
	Generated by makeSprites.js
*/

#include "SpriteData.h"

`;

const HEADER_COMMENT_H = `/*
	SpriteData.h
	------------
	Generated by makeSprites.js
*/

#ifndef SPRITEDATA_H
#define SPRITEDATA_H

`;

const FOOTER_H = `
#endif /* SPRITEDATA_H */
`;

function readBMP(filePath) {
    if (!fs.existsSync(filePath)) return null;
    const buffer = fs.readFileSync(filePath);
    const pixelOffset = buffer.readUInt32LE(10);
    const width = buffer.readInt32LE(18);
    const height = Math.abs(buffer.readInt32LE(22));
    const bitsPerPixel = buffer.readUInt16LE(28);
    const isTopDown = buffer.readInt32LE(22) < 0;

    if (bitsPerPixel !== 24) {
        throw new Error(`File ${path.basename(filePath)}: Only 24-bit BMPs supported.`);
    }

    const rowSize = Math.ceil((width * 3) / 4) * 4;
    const pixels = []; 

    for (let y = 0; y < height; y++) {
        const readY = isTopDown ? y : (height - 1 - y);
        let rowVal = 0n;
        for (let x = 0; x < width; x++) {
            const bIndex = pixelOffset + (readY * rowSize) + (x * 3);
            const b = buffer[bIndex];
            const g = buffer[bIndex + 1];
            const r = buffer[bIndex + 2];
            const brightness = (r + g + b) / 3;
            const bit = brightness < 128 ? 1n : 0n;
            const shift = BigInt(width - 1 - x);
            if (bit) rowVal |= (1n << shift);
        }
        pixels.push(rowVal);
    }
    return { width, height, pixels };
}

function getCType(width) {
    if (width <= 8) return "unsigned char";
    if (width <= 16) return "unsigned short";
    return "unsigned long";
}

try {
    if (!fs.existsSync(OUTPUT_DIR_C)) fs.mkdirSync(OUTPUT_DIR_C, { recursive: true });
    if (!fs.existsSync(OUTPUT_DIR_H)) fs.mkdirSync(OUTPUT_DIR_H, { recursive: true });

    let cOutput = HEADER_COMMENT_C;
    let hOutput = HEADER_COMMENT_H;

    // 1. Standard Sprites
    const rootFiles = fs.readdirSync(INPUT_DIR).filter(f => f.toLowerCase().endsWith('.bmp') && fs.statSync(path.join(INPUT_DIR, f)).isFile());
    const groups = {};

    rootFiles.forEach(file => {
        const base = path.basename(file, '.bmp');
        const match = base.match(/^(.+)_(\d+)$/);
        if (match) {
            const name = match[1];
            const idx = parseInt(match[2]);
            if (!groups[name]) groups[name] = { isArray: true, sprites: [] };
            groups[name].sprites[idx] = file;
        } else {
            groups[base] = { isArray: false, file: file };
        }
    });

    for (const name of Object.keys(groups)) {
        const entry = groups[name];
        if (entry.isArray) {
            let arrayWidth = 0;
            let blocks = [];
            for (let i = 0; i < entry.sprites.length; i++) {
                if (!entry.sprites[i]) continue;
                const data = readBMP(path.join(INPUT_DIR, entry.sprites[i]));
                if (arrayWidth === 0) arrayWidth = data.width;
                blocks.push(data.pixels);
            }
            const cType = getCType(arrayWidth);
            const innerLen = blocks[0].length;
            cOutput += `const ${cType} ${name}[][${innerLen}] = {\n`;
            blocks.forEach((pixels, idx) => {
                cOutput += `\t{\n`;
                pixels.forEach((row, rIdx) => {
                    cOutput += `\t0b${row.toString(2).padStart(arrayWidth, '0')}${rIdx < pixels.length - 1 ? ',' : ''}\n`;
                });
                cOutput += `\t}${idx < blocks.length - 1 ? ',' : ''}\n`;
            });
            cOutput += `};\n\n`;
            hOutput += `#define NUM_${name.replace(/^spr_/i, '').toUpperCase()} ${blocks.length}\n`;
            hOutput += `extern const ${cType} ${name}[][${innerLen}];\n\n`;
        } else {
            const data = readBMP(path.join(INPUT_DIR, entry.file));
            const cType = getCType(data.width);
            cOutput += `const ${cType} ${name}[] = {\n`;
            data.pixels.forEach((row, idx) => {
                cOutput += `\t0b${row.toString(2).padStart(data.width, '0')}${idx < data.pixels.length - 1 ? ',' : ''}\n`;
            });
            cOutput += `};\n\n`;
            hOutput += `extern const ${cType} ${name}[];\n\n`;
        }
    }

    // 2. Worm Sprites
    if (fs.existsSync(WORMS_DIR)) {
        const wormFiles = fs.readdirSync(WORMS_DIR).filter(f => f.toLowerCase().endsWith('.bmp'));
        const poses = {};
        wormFiles.forEach(file => {
            const match = file.match(/^worm_(.+?)_(Mask|Light|Dark|Outline)\.bmp$/i);
            if (match) {
                const pose = match[1];
                const type = match[2];
                if (!poses[pose]) poses[pose] = {};
                poses[pose][type] = file;
            }
        });

        const sortedPoses = Object.keys(poses).sort();
        const wormSpritePointers = [];
        const wormSpriteHeights = [];
        const wormSpriteTypes = [];
        let wormDefines = "";
        let currentSpriteIndex = 0;
        let totalWordsNeeded = 0;
        let generatedMaskWordsNeeded = 0;

        hOutput += `/* --- Worms Data --- */\n\n`;
        cOutput += `/* --- Worms Data --- */\n\n`;

        sortedPoses.forEach(pose => {
            const group = poses[pose];
            const hasOutline = !!group['Outline'];
            const typesToProcess = hasOutline ? ['Mask', 'Outline'] : ['Mask', 'Light', 'Dark'];

            // Find height from any available image in this pose group
            let poseHeight = 0;
            for (const type of ['Mask', 'Outline', 'Light', 'Dark']) {
                if (group[type]) {
                    const data = readBMP(path.join(WORMS_DIR, group[type]));
                    poseHeight = data.height;
                    break;
                }
            }

            typesToProcess.forEach(type => {
                totalWordsNeeded += poseHeight; // We need flip space for all sprites
                
                const cVarName = `worm_${pose}_${type}`;
                if (group[type]) {
                    const data = readBMP(path.join(WORMS_DIR, group[type]));
                    if (data.width !== 16) {
                        console.warn(`Warning: Worm sprite ${group[type]} is ${data.width}px wide. Expected 16.`);
                    }

                    cOutput += `const unsigned short ${cVarName}[] = {\n`;
                    data.pixels.forEach((row, idx) => {
                        cOutput += `\t0b${row.toString(2).padStart(16, '0')}${idx < data.pixels.length - 1 ? ',' : ''}\n`;
                    });
                    cOutput += `};\n\n`;
                    hOutput += `extern const unsigned short ${cVarName}[];\n`;
                    
                    wormSpritePointers.push(cVarName);
                    wormSpriteHeights.push(data.height);
                } else {
                    // Missing file, use 0 and inferred height
                    wormSpritePointers.push("0");
                    wormSpriteHeights.push(poseHeight);
                    if (type === 'Mask') {
                        generatedMaskWordsNeeded += poseHeight;
                    }
                }

                if (type === 'Mask') {
                    wormSpriteTypes.push(0); // 0 = Mask
                    wormDefines += `#define WORM_${pose.toUpperCase()}_MASK ${currentSpriteIndex++}\n`;
                } else {
                    wormSpriteTypes.push(1); // 1 = Component
                    if (type === 'Outline') {
                        wormDefines += `#define WORM_${pose.toUpperCase()}_LIGHT ${currentSpriteIndex}\n`;
                        wormDefines += `#define WORM_${pose.toUpperCase()}_DARK ${currentSpriteIndex++}\n`;
                    } else if (type === 'Light') {
                        wormDefines += `#define WORM_${pose.toUpperCase()}_LIGHT ${currentSpriteIndex++}\n`;
                    } else if (type === 'Dark') {
                        wormDefines += `#define WORM_${pose.toUpperCase()}_DARK ${currentSpriteIndex++}\n`;
                    }
                }
            });
            hOutput += "\n";
        });

        hOutput += `#define NUM_WORM_SPRITES ${currentSpriteIndex}\n`;
        hOutput += `#define WORM_FLIP_BUFFER_SIZE ${totalWordsNeeded}\n`;
        hOutput += `#define WORM_GENERATED_MASK_BUFFER_SIZE ${generatedMaskWordsNeeded}\n\n`;
        hOutput += wormDefines;

        cOutput += `unsigned short* wormsSprites[] = {\n`;
        cOutput += wormSpritePointers.map(ptr => `\t(unsigned short*)${ptr}`).join(',\n') + `\n};

`;

        cOutput += `const unsigned char wormSpriteHeights[] = {\n`;
        cOutput += wormSpriteHeights.join(', ') + `\n};

`;

        cOutput += `const unsigned char wormSpriteTypes[] = {\n`;
        cOutput += wormSpriteTypes.join(', ') + `\n};

`;

        hOutput += `extern unsigned short* wormsSprites[];\n`;
        hOutput += `extern const unsigned char wormSpriteHeights[];\n`;
        hOutput += `extern const unsigned char wormSpriteTypes[];\n`;
    }

    hOutput += FOOTER_H;
    fs.writeFileSync(OUTPUT_FILE_C, cOutput);
    fs.writeFileSync(OUTPUT_FILE_H, hOutput);
    console.log(`Success!`);
} catch (err) { console.error("Error:", err); }