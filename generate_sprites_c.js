const fs = require('fs');
const path = require('path');

const INPUT_DIR = 'SpriteBitmaps';
const OUTPUT_FILE = 'Game/SpriteData.c';

// Helper: Convert number to 32-bit binary string
function toBinary(num, width) {
    return '0b' + num.toString(2).padStart(width, '0');
}

// Parse BMP manually to get pixels
function readBMP(filePath) {
    const buffer = fs.readFileSync(filePath);
    
    // Basic BMP Parsing
    const pixelOffset = buffer.readUInt32LE(10);
    const width = buffer.readInt32LE(18);
    const height = Math.abs(buffer.readInt32LE(22)); // Height can be negative
    const bitsPerPixel = buffer.readUInt16LE(28);
    const isTopDown = buffer.readInt32LE(22) < 0;

    if (bitsPerPixel !== 24) {
        throw new Error(`Only 24-bit BMPs supported (found ${bitsPerPixel})`);
    }

    const rowSize = Math.ceil((width * 3) / 4) * 4;
    const pixels = []; // Array of ints representing the rows

    for (let y = 0; y < height; y++) {
        const readY = isTopDown ? y : (height - 1 - y);
        let rowVal = 0n; // Use BigInt for 32-bit safety

        for (let x = 0; x < width; x++) {
            const bIndex = pixelOffset + (readY * rowSize) + (x * 3);
            const b = buffer[bIndex];
            const g = buffer[bIndex + 1];
            const r = buffer[bIndex + 2];

            // Simple threshold: Dark = 1, Light = 0
            const brightness = (r + g + b) / 3;
            const bit = brightness < 128 ? 1n : 0n;

            // Add bit to position (MSB is index 0)
            const shift = BigInt(width - 1 - x);
            if (bit) rowVal |= (1n << shift);
        }
        pixels.push(rowVal);
    }

    return { width, height, pixels };
}

// Main Logic
try {
    const files = fs.readdirSync(INPUT_DIR).filter(f => f.endsWith('.bmp'));
    
    // Group files for 2D arrays (e.g. spr_weapons_0, spr_weapons_1)
    const groups = {};
    
    files.forEach(file => {
        const base = path.basename(file, '.bmp');
        // Check for _index suffix
        const match = base.match(/^(.+)_(\d+)$/);
        
        if (match) {
            const name = match[1];
            const idx = parseInt(match[2]);
            if (!groups[name]) groups[name] = { isArray: true, sprites: [] };
            groups[name].sprites[idx] = file;
        } else {
            groups[base] = { isArray: false, file: file };
        }
    });

    let cOutput = "// Generated by regenerate_c.js\n\n";

    for (const name of Object.keys(groups)) {
        const entry = groups[name];

        if (entry.isArray) {
            // Handle 2D Array
            let arrayWidth = 0;
            let arrayType = "";
            let blocks = [];

            // Process all parts to determine type and collect data
            for (let i = 0; i < entry.sprites.length; i++) {
                if (!entry.sprites[i]) continue; // Skip gaps if any
                
                const data = readBMP(path.join(INPUT_DIR, entry.sprites[i]));
                
                // Validate Width
                if (arrayWidth === 0) arrayWidth = data.width;
                else if (arrayWidth !== data.width) {
                    console.warn(`WARNING: ${name} index ${i} has width ${data.width}, expected ${arrayWidth}.`);
                }

                blocks.push(data.pixels);
            }

            // Determine C Type
            if (arrayWidth === 8) arrayType = "unsigned char";
            else if (arrayWidth === 16) arrayType = "unsigned short";
            else if (arrayWidth === 32) arrayType = "unsigned long";
            else {
                console.warn(`WARNING: ${name} has odd width ${arrayWidth}. defaulting to unsigned long.`);
                arrayType = "unsigned long";
            }

            // Generate C Code
            // UPDATED LINE: Added comment // X tall
            cOutput += `static ${arrayType} ${name}[][${blocks[0].length}] = { // ${blocks[0].length} tall\n`;
            
            blocks.forEach((pixels, idx) => {
                cOutput += `\t{\n`;
                pixels.forEach((row, rIdx) => {
                    let binStr = row.toString(2).padStart(arrayWidth, '0');
                    cOutput += `\t0b${binStr}${rIdx < pixels.length - 1 ? ',' : ''}\n`;
                });
                cOutput += `\t}${idx < blocks.length - 1 ? ',' : ''}\n`;
            });
            cOutput += `};\n\n`;
            console.log(`Generated 2D array: ${name}`);

        } else {
            // Handle Single Array
            const data = readBMP(path.join(INPUT_DIR, entry.file));
            
            let cType = "";
            if (data.width === 8) cType = "unsigned char";
            else if (data.width === 16) cType = "unsigned short";
            else if (data.width === 32) cType = "unsigned long";
            else {
                console.warn(`WARNING: ${name} has non-standard width ${data.width}.`);
                cType = "unsigned long"; // fallback
            }

            // UPDATED LINE: Matches existing logic
            cOutput += `static ${cType} ${name}[] = { // ${data.height} tall\n`;
            data.pixels.forEach((row, idx) => {
                let binStr = row.toString(2).padStart(data.width, '0');
                cOutput += `\t0b${binStr}${idx < data.pixels.length - 1 ? ',' : ''}\n`;
            });
            cOutput += `};\n\n`;
            console.log(`Generated array: ${name}`);
        }
    }

    fs.writeFileSync(OUTPUT_FILE, cOutput);
    console.log(`\nSuccess! File written to ${OUTPUT_FILE}`);

} catch (err) {
    console.error("Error:", err);
}