const fs = require('fs');
const path = require('path');

// Configuration
const INPUT_DIR = 'SpriteBitmaps';
const OUTPUT_DIR_C = 'c';
const OUTPUT_DIR_H = 'h';
const OUTPUT_FILE_C = path.join(OUTPUT_DIR_C, 'SpriteData.c');
const OUTPUT_FILE_H = path.join(OUTPUT_DIR_H, 'SpriteData.h');

// File Header Boilerplate
const HEADER_COMMENT_C = `/*
	SpriteData.c
	------------
	
	For now this is where we'll store our raw sprite data.
	
	Perhapse at some point in the future we'll consider compression with RLE or similar.	
*/

// includes
#include "SpriteData.h"

// Generated by regenerate_c.js

`;

const HEADER_COMMENT_H = `/*
	SpriteData.h
	------------
	
	Main header file for the SpriteData.c module
*/

#ifndef SPRITEDATA_H
#define SPRITEDATA_H

/* NOTE:
	These must be defined in SpriteData.c as non-static, ideally const.
*/

`;

const FOOTER_H = `
#endif /* SPRITEDATA_H */
`;

// Helper: Convert number to 32-bit binary string
function toBinary(num, width) {
    return '0b' + num.toString(2).padStart(width, '0');
}

// Parse BMP manually to get pixels
function readBMP(filePath) {
    const buffer = fs.readFileSync(filePath);
    
    // Basic BMP Parsing
    const pixelOffset = buffer.readUInt32LE(10);
    const width = buffer.readInt32LE(18);
    const height = Math.abs(buffer.readInt32LE(22));
    const bitsPerPixel = buffer.readUInt16LE(28);
    const isTopDown = buffer.readInt32LE(22) < 0;

    if (bitsPerPixel !== 24) {
        throw new Error(`Only 24-bit BMPs supported (found ${bitsPerPixel})`);
    }

    const rowSize = Math.ceil((width * 3) / 4) * 4;
    const pixels = []; 

    for (let y = 0; y < height; y++) {
        const readY = isTopDown ? y : (height - 1 - y);
        let rowVal = 0n; // Use BigInt for 32-bit safety

        for (let x = 0; x < width; x++) {
            const bIndex = pixelOffset + (readY * rowSize) + (x * 3);
            const b = buffer[bIndex];
            const g = buffer[bIndex + 1];
            const r = buffer[bIndex + 2];

            // Simple threshold: Dark = 1, Light = 0
            const brightness = (r + g + b) / 3;
            const bit = brightness < 128 ? 1n : 0n;

            // Add bit to position (MSB is index 0)
            const shift = BigInt(width - 1 - x);
            if (bit) rowVal |= (1n << shift);
        }
        pixels.push(rowVal);
    }

    return { width, height, pixels };
}

// Main Logic
try {
    // Ensure output directories exist
    if (!fs.existsSync(OUTPUT_DIR_C)) fs.mkdirSync(OUTPUT_DIR_C, { recursive: true });
    if (!fs.existsSync(OUTPUT_DIR_H)) fs.mkdirSync(OUTPUT_DIR_H, { recursive: true });

    const files = fs.readdirSync(INPUT_DIR).filter(f => f.endsWith('.bmp'));
    
    // Group files for 2D arrays (e.g. spr_weapons_0, spr_weapons_1)
    const groups = {};
    
    files.forEach(file => {
        const base = path.basename(file, '.bmp');
        // Check for _index suffix
        const match = base.match(/^(.+)_(\d+)$/);
        
        if (match) {
            const name = match[1];
            const idx = parseInt(match[2]);
            if (!groups[name]) groups[name] = { isArray: true, sprites: [] };
            groups[name].sprites[idx] = file;
        } else {
            groups[base] = { isArray: false, file: file };
        }
    });

    let cOutput = HEADER_COMMENT_C;
    let hOutput = HEADER_COMMENT_H;

    for (const name of Object.keys(groups)) {
        const entry = groups[name];

        if (entry.isArray) {
            // Handle 2D Array
            let arrayWidth = 0;
            let arrayType = "";
            let blocks = [];

            // Process all parts to determine type and collect data
            for (let i = 0; i < entry.sprites.length; i++) {
                if (!entry.sprites[i]) continue; 
                
                const data = readBMP(path.join(INPUT_DIR, entry.sprites[i]));
                
                if (arrayWidth === 0) arrayWidth = data.width;
                else if (arrayWidth !== data.width) {
                    console.warn(`WARNING: ${name} index ${i} has width ${data.width}, expected ${arrayWidth}.`);
                }

                blocks.push(data.pixels);
            }

            // Determine C Type
            if (arrayWidth === 8) arrayType = "unsigned char";
            else if (arrayWidth === 16) arrayType = "unsigned short";
            else if (arrayWidth === 32) arrayType = "unsigned long";
            else {
                console.warn(`WARNING: ${name} has odd width ${arrayWidth}. defaulting to unsigned long.`);
                arrayType = "unsigned long";
            }

            const innerLen = blocks[0].length;
            const count = blocks.length;

            // Generate Define Name: spr_weapons -> NUM_WEAPONS
            const defineName = "NUM_" + name.replace(/^spr_/i, '').toUpperCase();

            // --- C Output ---
            cOutput += `const ${arrayType} ${name}[][${innerLen}] = { // ${innerLen} tall\n`;
            blocks.forEach((pixels, idx) => {
                cOutput += `\t{\n`;
                pixels.forEach((row, rIdx) => {
                    let binStr = row.toString(2).padStart(arrayWidth, '0');
                    cOutput += `\t0b${binStr}${rIdx < pixels.length - 1 ? ',' : ''}\n`;
                });
                cOutput += `\t}${idx < blocks.length - 1 ? ',' : ''}\n`;
            });
            cOutput += `};\n\n`;

            // --- H Output ---
            hOutput += `#define ${defineName} ${count}\n`;
            hOutput += `extern const ${arrayType} ${name}[][${innerLen}];\n\n`;

            console.log(`Generated 2D array: ${name} (Count: ${count})`);

        } else {
            // Handle Single Array
            const data = readBMP(path.join(INPUT_DIR, entry.file));
            
            let cType = "";
            if (data.width === 8) cType = "unsigned char";
            else if (data.width === 16) cType = "unsigned short";
            else if (data.width === 32) cType = "unsigned long";
            else {
                console.warn(`WARNING: ${name} has non-standard width ${data.width}.`);
                cType = "unsigned long"; // fallback
            }

            // --- C Output ---
            cOutput += `const ${cType} ${name}[] = { // ${data.height} tall\n`;
            data.pixels.forEach((row, idx) => {
                let binStr = row.toString(2).padStart(data.width, '0');
                cOutput += `\t0b${binStr}${idx < data.pixels.length - 1 ? ',' : ''}\n`;
            });
            cOutput += `};\n\n`;

            // --- H Output ---
            hOutput += `extern const ${cType} ${name}[];\n\n`;

            console.log(`Generated array: ${name}`);
        }
    }

    // Finalize H file
    hOutput += FOOTER_H;

    fs.writeFileSync(OUTPUT_FILE_C, cOutput);
    fs.writeFileSync(OUTPUT_FILE_H, hOutput);
    
    console.log(`\nSuccess!`);
    console.log(`Written C file to: ${OUTPUT_FILE_C}`);
    console.log(`Written H file to: ${OUTPUT_FILE_H}`);

} catch (err) {
    console.error("Error:", err);
}